#include <kinfu/kinect_fusion_eigen_pose_estimation_pipeline_block.hpp>
#include <kinfu/cpu_pipeline_value.hpp>
#include <kinfu/pipeline_value.hpp>
#include <Eigen/Dense>
#include <cassert>
#include <cmath>
#include <exception>
#include <memory>
#include <stdexcept>
#include <tuple>
#include <utility>


#include <iostream>

namespace kinfu {

	static bool isfinite (const Eigen::Vector3f & v) noexcept {
		return std::isfinite(v(0)) && std::isfinite(v(1)) && std::isfinite(v(2));
	}
	kinect_fusion_eigen_pose_estimation_pipeline_block::kinect_fusion_eigen_pose_estimation_pipeline_block (
		float epsilon_d,
		float epsilon_theta,
		std::size_t frame_width, 
		std::size_t frame_height,
		Eigen::Matrix4f t_gk_initial,
		std::size_t numit,
		bool force_px_px
	) : epsilon_d_(epsilon_d), epsilon_theta_(epsilon_theta), frame_width_(frame_width), frame_height_(frame_height), numit_(numit), t_gk_initial_(std::move(t_gk_initial)), force_px_px_(force_px_px) {}


	Eigen::Matrix4f kinect_fusion_eigen_pose_estimation_pipeline_block::incremental(
		measurement_pipeline_block::value_type::element_type & map,
		measurement_pipeline_block::value_type::element_type & prev_map,
		Eigen::Matrix3f k,
		Eigen::Matrix4f t_frame_frame,
		Eigen::Matrix4f t_z
	) {

		// Compute correspondences via projective data association

		std::size_t rej_m = 0;
		std::size_t rej_ed = 0;
		std::size_t rej_et = 0;
		std::size_t rej_oob = 0;
		std::size_t numpts = frame_height_ * frame_width_;


		long long int u_std = 0;
		long long int v_std = 0;

		std::vector<std::tuple<Eigen::Vector3f, Eigen::Vector3f, Eigen::Vector3f>> correspondences;

		auto && u_map = map.get();
		auto && u_prev_map = prev_map.get();

		for (std::size_t i = 0; i < numpts; ++i) {

			// measured v and n maps from current frame. These are in current camera space.
			auto v = u_map[i].v;
			auto n = u_map[i].n;

			if (!isfinite(v) || !isfinite(n)) {
				rej_m++;
				continue;
			}

			Eigen::Vector4f v_h(v(0), v(1), v(2), 1.0f);

			// Transform v to previous camera space, using t_frame_to_frame
			auto v_cp_h = (t_frame_frame * v_h).eval();

			assert(v_cp_h(3) == 1.0f);

			// Convert to image coordinates
			Eigen::Vector3f v_cp(v_cp_h(0), v_cp_h(1), v_cp_h(2));
			auto uv3 = k * v_cp;
			Eigen::Vector2f uv(uv3(0)/uv3(2),uv3(1)/uv3(2));

			auto uv_u = std::int32_t(std::round(uv(0)));
			auto uv_v = std::int32_t(std::round(uv(1)));

			auto curr_u = i % frame_width_;
			auto curr_v = i / frame_width_;

			u_std += (curr_u - uv_u);
			v_std += (curr_v - uv_v);

			if (uv_u < 0 || uv_u >= std::int32_t(frame_width_) || uv_v < 0 || uv_v >= std::int32_t(frame_height_)) {
				rej_oob++;
				continue;
			}

			// convert uv coords to lin_idx
			std::int32_t lin_idx = std::int32_t(std::round(uv(0))) + std::int32_t(std::round(uv(1))) * frame_width_;

			// In world coordinates
			auto pv = u_prev_map[lin_idx].v;
			auto pn = u_prev_map[lin_idx].n;

			if (!isfinite(pn) || !isfinite(pv)) {
				rej_m++;
				continue;
			}

			// Test epsilon d
			Eigen::Vector4f pv_homo(pv(0), pv(1), pv(2), 1.0); // pv homo in world
			Eigen::Vector4f v_w_h = t_z * v_h; // v homo in world
			assert(v_w_h(3) == 1.0f);
			if ( (v_w_h - pv_homo).norm() > epsilon_d_) {
				rej_ed++;
				continue;
			} 

			// Test epsilon theta
			auto r_z = t_z.block<3,3>(0,0); // rotation block of t_z
			if ( (r_z*n).cross(pn).norm() > epsilon_theta_ ) {
				rej_et++;
				continue;
			}
			Eigen::Vector3f v_w(v_w_h(0), v_w_h(1), v_w_h(2)); // v in world space
			// if we get to here the correspondence is valid
			correspondences.emplace_back(std::make_tuple(
				v_w, // <- in global space
				pv,
				pn	 
			));
		}


		std::cout << "Average difference in uv" << std::endl;
		std::cout << "\tu:" << float(u_std)/numpts << std::endl;
		std::cout << "\tv:" << float(v_std)/numpts << std::endl;

		std::cout << "Correspondences summary:" << std::endl;
		std::cout << "\t Rej due to NaN: " << rej_m << std::endl;
		std::cout << "\t Rej due to distance: " << rej_ed << std::endl;
		std::cout << "\t Rej due to angle: " << rej_et << std::endl;
		std::cout << "\t Rej due to oob: " << rej_oob << std::endl;


		// 6 is the DOF, so we need 6 points to solve minimum
		if (correspondences.size() < 6) {
			// I think this means we have blown our tracking... what to do...
			throw pose_estimation_pipeline_block::tracking_lost_error("Less than 6 correspondences were found");
		} 

		// build and sum up the matrices
		Eigen::Matrix<float, 6, 6> A = Eigen::Matrix<float, 6, 6>::Zero();
		Eigen::Matrix<float, 6, 1> b = Eigen::Matrix<float, 1, 6>::Zero();

		for (auto && cor : correspondences) {

			// For this correspondence, we find the optimal transformation
			// to be applied to p that minimizes its distance from the
			// plane generated by q and n

			auto && p = std::get<0>(cor); // v
			auto && q = std::get<1>(cor); // pv
			auto && n = std::get<2>(cor); // pn

			auto c = p.cross(n);

			auto pqn = (p-q).dot(n); // for b vector

			Eigen::Matrix<float, 6, 6> Ai;
			Ai << c(0)*c(0), c(0)*c(1), c(0)*c(2), c(0)*n(0), c(0)*n(1), c(0)*n(2),
				  c(1)*c(0), c(1)*c(1), c(1)*c(2), c(1)*n(0), c(1)*n(1), c(1)*n(2),
				  c(2)*c(0), c(2)*c(1), c(2)*c(2), c(2)*n(0), c(2)*n(1), c(2)*n(2),
				  n(0)*c(0), n(0)*c(1), n(0)*c(2), n(0)*n(0), n(0)*n(1), n(0)*n(2),
				  n(1)*c(0), n(1)*c(1), n(1)*c(2), n(1)*n(0), n(1)*n(1), n(1)*n(2),
				  n(2)*c(0), n(2)*c(1), n(2)*c(2), n(2)*n(0), n(2)*n(1), n(2)*n(2);

			
			Eigen::Matrix<float, 6, 1> bi;
			
			bi << c(0), c(1), c(2), n(0), n(1), n(2);
			bi *= pqn * (-1);

			A = A + Ai;
			b = b + bi;

		}


		// Solve the system by column pivot - TODO: use Cholesky?
		Eigen::Matrix<float, 6, 1> x = A.colPivHouseholderQr().solve(b);
		
		float alpha = x(0);
		float beta =  x(1);
		float gamma = x(2);
		float tx = x(3);
		float ty = x(4);
		float tz = x(5);

		Eigen::Matrix4f to_return;
		to_return << 1.0f, -gamma, beta, tx,
					 gamma, 1.0f, -alpha, ty,
				 	 -beta, alpha, 1.0f, tz,
					 0.0f, 0.0f, 0.0f, 1.0f;
		
		// to_return should be the best transformation that brings v into alignment with pv

		//std::cout << "to_return" << std::endl << to_return << std::endl;

		return to_return;

	}





	kinect_fusion_eigen_pose_estimation_pipeline_block::value_type kinect_fusion_eigen_pose_estimation_pipeline_block::operator () (
		measurement_pipeline_block::value_type::element_type & map,
		measurement_pipeline_block::value_type::element_type * prev_map,
		Eigen::Matrix3f k,
		value_type t_gk_minus_one
	) {
		
		// Emplace the initial tgk and return if this is the first time we are running
		using pv_type=cpu_pipeline_value<value_type::element_type::type>;
	
		if (!(t_gk_minus_one && prev_map)) {

			t_gk_minus_one=std::make_unique<pv_type>();
			static_cast<pv_type &>(*t_gk_minus_one).emplace(t_gk_initial_);

			return t_gk_minus_one;

		}

		// Extract previous tgk
		auto && pv=dynamic_cast<pv_type &>(*t_gk_minus_one);
		auto t_gk_minus_one_m=pv.get();
		Eigen::Matrix4f t_z(t_gk_minus_one_m);
		Eigen::Matrix4f t_gk_prev_inverse(t_gk_minus_one_m.inverse());
		

		// Iterate
		for (std::size_t i = 0; i < numit_; ++i) {

			// Should be identity the first time this runs

			// t_frame_frame goes from current camera to previous frame's camera
			Eigen::Matrix4f t_frame_frame(t_gk_prev_inverse * t_z);

			// If enabled, force pixel to pixel correspondences
			if (force_px_px_) t_frame_frame = Eigen::Matrix4f::Identity();

			//Eigen::Matrix4f t_frame_frame(Eigen::Matrix4f::Identity()); // WHY??? THIS IS INSANITY
			
			std::cout << "t_frame_frame" << std::endl << t_frame_frame << std::endl;
			std::cout << "original t_z" << std::endl << t_z << std::endl;
			// Minimize the energy of the linearized system, giving the incremental update and apply to t_z
			//auto t_z_new = t_z;
			auto inc = incremental(map, *prev_map, k, t_frame_frame, t_z);
			std::cout << "inc" << std::endl << inc << std::endl;
			//iterate returns an incremental update that takes us from the prev world to an updated estimate
			t_z = inc * t_z;

			std::cout << "updated t_z:" << std::endl << t_z << std::endl;
			//std::cout << "t_z changed:" << std::boolalpha << (t_z_new != t_z) << std::endl; 

		}

		pv.emplace(t_z);
		return t_gk_minus_one;
	}
	


}
